##### 程序通常编译过程
1. 预编译器进行预编译处理，将类似宏的结构替换，inline展开等
2. 编译器接收步骤1的输出，生成对应的汇编文件
3. 汇编器接收步骤2的输出：汇编文件，生成可执行文件
4. 链接器将可执行文件链接：主要是符号解析，重定位

##### 目标文件组成
* .text：机器码
* .data：已经初始化的全局变量
* .bss：未初始化的全局变量
* ...其他的比较琐碎，比如符号表，debug，line和text映射等

##### CPP和Java的重载
CPP和Java会是通过函数名和函数参数来区别重载函数的，实现是通过函数和函数参数来生成一个唯一的名字：比如 函数名_adsf类名xx， 这样一类的来唯一区别

##### 在CPP中全局变量
在CPP中不同文件定义了同名的全局变量，那么很容易出现类似这边修改了，影响另外一边的情况，如果是一个是int（初始化）， 一个是double（未初始化）， 那么可能用double赋值的时候，将int后面的覆盖了（字节数不一样）。

##### 静态链接库
链接器构造可执行文件时，只拷贝静态库里面被应用程序引用的目标模块（不是拷贝全部文件）。
多个静态库如果不是独立的，那么在link时候要注意顺序－>可以将这些静态库合并成一个静态库
在CPP中需要引入对应的头文件，然后在对应link的时候，引入对应的汇编文件

##### 动态链接共享库
在运行时，由动态链接器来执行。在Linux中为.so文件，在Windows中为.dll文件。只拷贝了一些重定位和符号表信息，然后可以解析到对应的代码和数据的引用上。
另外Java的JNI调用本地的C和CPP函数，就是将对应的函数编译到共享库中，然后动态加载进来。

1. 将动态链接库重定位到某个存储器段
2. 重定位使用动态链接库的文本和数据到1中的位置

##### 加载器加载文件运行
shell运行一个程序时，父shell进程生成子进程。子进程复制了父进程，然后通过execve调用加载器。
加载器删除子进程现有的虚拟存储器段，同时创建新的代码，数据，堆，栈段。新的栈和堆段被初始化为0。同时将虚拟地址空间中的页映射到可执行文件的页大小的片（chunk），然后新代码和数据段被初始化为可执行文件的内容。最后加载器跳转到_start地址，最后调用main函数



