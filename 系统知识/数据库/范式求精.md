# 数据库

### 模式分解依据
* 无损连接性：就是分解之后，可以通过分解出来的实例来恢复之前的所有实例，比如说一个学生课程表－>学生表加课程表，如果你是按照名字来分割的话，在连接的时候，如果存在同名的人，必然连接出不在原来表中的数据，导致原来的信息有缺损。无损就是你用ID来分割，ID必然没有重复，可以恢复出原来一模一样的数据，可以恢复出原来的学生课程表。 
* 依赖保持性：依赖保持性，就是在原来关系上的依赖，在分解完之后依然存在。比如学生和选课的关系，应该在分解完的关系上还有体现。

### 分解的优缺点
分解会消除数据重复（冗余），避免插入，删除...等操作的问题。但是查询的时候要连接，所以查询速度会相应变慢，实际中我们会保留适当的冗余来提高插寻速度。

### 函数依赖的计算规则
下面的值是代表属性，比如学号，成绩...
 
* 自反律：Y属于X，那么X->Y
* 增补律：X->Y，那么对于任何Z，都有XZ->YZ
* 传递律：X->Y, Y->Z,那么X->Z
* 合并：X->Y, X->Z,那么X->YZ
* 分解：X->YZ,那么X->Y, X->Z

### 属性闭包
属性闭包X+就是属性集X对于一个依赖集F推到出来的最小的闭包。任何闭包F+，都有F+包含X+。

计算方法：

1. 把属性集X当成初始条件，当成属性集Y
2. 判断是否可以通过Y中属性在F中获得新的属性，如果可以获得，那么加入到Y中
3. 重复2，直到获取不到新的属性

### 常见范式
1NF，2NF，3NF，BCNF, 依次增加条件，满足后面的必然满足前面的要求

* 1NF：满足属性不可再分，比如不能再嵌套一个表进去。
* 2NF：在1NF的基础上，去掉非主属性对码的部分函数依赖。部分函数依赖就是：在学生成绩表中，（学号，课名）->学生，这个是完全函数依赖。但是（学号）->系主任，这叫部分函数依赖，因为实际上系主任只依赖于学号，不用依赖于码（学号，课名）。
* 3NF：在2NF的基础上，消除非主属性的传递依赖。身份证->学生ID， 学生ID->学生名字，所以身份证->学生名字。
* BCND：在3NF上，消除主属性的函数依赖传递。


### BCNF
X是R属性上的一个子集，A是R的一个属性。那么如果存在X->A，那么

* A属于X，即自反律，平凡函数依赖 或
* 或者X是超码

所以对于一个关系集，只要判断每个关系的左边是否是超码即可。

分解成BCNF过程：

1. 对于一个属性集合R，如果存在关系X->Y不符合BCNF，且X交Y为空，那么分解为R－Y，XY
2. 如果R－Y，XY依然不符合，那么重复分解下去
3. 判断步骤2是否符合BCNF有2种方法
* 一个是要判断原来关系集F的闭包F＋，是否在分解出来的属性集的投影满足BCNF（就是可能借助不在这个属性集中的属性推导出不符合BCNF的关系）
* 一个是判断分解出来的属性集R1的所有属性子集｛A1，A2...｝中任意一个属性子集A，在原来F下的属性闭包A＋是否包含整个属性子集R1或者不包含R1-A中的任意属性
上面的算法是无损分解的，所以要判断依赖保持性
有时候分解完后会丧失一部分依赖，可以先判断在分解的属性集中保留了原来的那些依赖，如果没有完全保留，就使用依赖保持算法来判断，如果还是没有，那么就添加进去

### 3NF
对于关系模式R，有一个函数依赖集合F，X是R属性集的一个子集，A是R属性的一个属性。对于函数依赖X->A，有：

* A属于X 或
* X是超码 或
* A是R的码的一部分

求解方法：

1. 3NF分解

* 类似BCNF分解（所以有无损分解性， 只是判断的条件不一样）
* 然后判断依赖是否在
* 如果OK，则分解成功，如果没有保持的依赖，那么就直接添加。

2. 3NF合成
* 先求最小依赖覆盖R1，R2...
* 然后直接用R1，R2...（有相同条件的可以合在一起）
* 判断是否无损，如果不是无损，加一个码即可

### 最小依赖覆盖
* 先最小化依赖右边，将右边都变成单属性
* 然后最小化左边，去掉不必要的属性
* 然后去除传递依赖

### 超码，候选码，主码区别
超码就是可以惟一表示实体的属性集，任何包含超码的都是超码。候选码就是最小化的超码，他的真子集中没有超码。主码就是指定的那个唯一的候选码。

### 判断无损分解
分解成2部分R1，R2。如果R1与R2的交集是R1的超码或是R2的超码（就是交集可以推出R1或R2），那么这个分解是无损的

### 判断依赖保持
直接看在分解之后的R上的关系，是否可以保持原来的原来的依赖。如果没有。

* 那么没有保持的依赖 X->Y
* 使用result ＝ X；
* 然后依次判断每个分解R, t = (result 交 R)+ 交 R， result ＝ result 并 t。
* 最后所有的R都判断完了，看result是否包含Y的所有属性，如果有，则依赖保持，如果没有，则这个依赖没有保持。

